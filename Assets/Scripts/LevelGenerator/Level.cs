using UnityEngine;
using UnityEngine.Networking;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;

/// <summary>
/// A room library is a Dictionary of a Dictionary of a List of Rooms
/// Give it a specified entrance number, a dimension of room you want, and which room you want in that list
/// <para>Get a random room with GetRandom(int entrances, Vector2 size)</para>
/// </summary>
public class RoomLibrary
{
    private Dictionary<int, Dictionary<Vector2, List<Room>>> _room_lib;
    /// <summary>
    /// Constructor.
    /// </summary>
    public RoomLibrary()
    {
        _room_lib = new Dictionary<int, Dictionary<Vector2, List<Room>>>();
    }
    /// <summary>
    /// Clears the RoomLibrary. Be careful when using this!
    /// </summary>
    public void ClearAll()
    {
        _room_lib = new Dictionary<int, Dictionary<Vector2, List<Room>>>();
    }
    /// <summary>
    /// Add a room to the RoomLibrary. The RoomLibrary will analyze the number of
    /// entrances and size for you.
    /// 
    /// <para>TODO: This creates and deletes a temporary game object for analysis. This needs to change in the future</para>
    /// </summary>
    /// <param name="r"></param>
    public void Add(Room r)
    {
        Room temp = UnityEngine.Object.Instantiate<Room>(r);
        int entrances = temp.GetEntrances().Count;
        UnityEngine.Object.Destroy(temp.gameObject);

        Vector2 size = new Vector2(r.width, r.height);

        if (!_room_lib.ContainsKey(entrances))
            _room_lib[entrances] = new Dictionary<Vector2, List<Room>>();
        if (!_room_lib[entrances].ContainsKey(size))
            _room_lib[entrances][size] = new List<Room>();
        _room_lib[entrances][size].Add(r);
    }
    /// <summary>
    /// Get us a random room from the RoomLibrary with the specifications.
    /// Returns null if nothing is found.
    /// </summary>
    /// <param name="entrances"></param>
    /// <param name="size"></param>
    /// <returns></returns>
    public Room GetRandom(int entrances, Vector2 size)
    {
        if (!_room_lib.ContainsKey(entrances))
            return null;
        if (!_room_lib[entrances].ContainsKey(size))
            return null;
        if (_room_lib[entrances][size].Count == 0)
            return null;
        return _room_lib[entrances][size][UnityEngine.Random.Range(0, _room_lib[entrances][size].Count)];
    }
    public override string ToString()
    {
        int _total_rooms = 0;
        System.Text.StringBuilder _to_return = new System.Text.StringBuilder();
        _to_return.Append(_room_lib.Keys.Count.ToString() + " unique number of entrances\n");
        foreach(KeyValuePair <int, Dictionary<Vector2,List<Room>>> layer1 in _room_lib)
        {
            _to_return.Append("    Entrances: [" + layer1.Key.ToString() + "], " + layer1.Value.Keys.Count.ToString() + " unique dimensions\n");
            foreach (KeyValuePair<Vector2,List<Room>> layer2 in layer1.Value)
            {
                _to_return.Append("        Dimensions: [x:" + layer2.Key.x.ToString() + ", y:" + layer2.Key.y.ToString() + "] - ");
                _to_return.Append(layer2.Value.Count.ToString() + " of these\n");
                _total_rooms += layer2.Value.Count;
            }
        }
        return " RoomLibrary: " + _total_rooms.ToString() + " rooms total\n\n" + _to_return.ToString();
    }
}

public class Level : NetworkBehaviour
{
    /// <summary>
    /// A library of all the different types of rooms we've loaded.
    /// </summary>
    private RoomLibrary _room_lib;
    /// <summary>
    /// A list of all our spawn rooms.
    /// </summary>
    public List<Room> _spawn_rooms;
    /// <summary>
    /// A list of all the rooms already generated by our generator.
    /// </summary>
    public List<Room> current_rooms;

    // while our gameobjects is less than this amount, we can't close entrances
    // don't make this more than DecelerateAt
    public int AccelerateUntil = 2;

    // once our gameobjects hits this amount, we need to start closing entrances
    public int DecelerateAt = 50;
    /// <summary>
    /// A check of whether our level generation is done or not.
    /// </summary>
    public bool done;


    private void Awake()
    {
        current_rooms = new List<Room>();
        done = false;
        _LoadResources();
    }

    private void Start()
    {
        CreateSpawn(new Vector2(0, 0));
        StartCoroutine("GenerateRooms"); // We put this in Start() because rooms have to access the levelgenerator, and it isn't created until Awake() finishes
    }


    public int AvailableEntrances()
    {
        int to_return = 0;
        foreach (Room room in current_rooms)
            to_return += room.AvailableEntrances();
        return to_return;
    }
    /// <summary>
    /// Updates the available entrances of all rooms. Try not to use this too often, it loops through every single room!
    /// </summary>
    public void UpdateAvailableEntrancesAll()
    {
        foreach (Room room in current_rooms)
            room.UpdateAvailableEntrances(current_rooms);
    }
    private void _LoadResources()
    {
        _LoadSpawnRooms();
        _LoadRooms();
    }
    private void _LoadSpawnRooms()
    {
        _spawn_rooms = new List<Room>();
        GameObject[] rooms = Resources.LoadAll<GameObject>("SpawnRooms");
        if (rooms.Length == 0)
            Debug.LogError("No spawn rooms found!");
        foreach (GameObject g in rooms)
        {
            Room r = g.GetComponent<Room>();
            _spawn_rooms.Add(r);
        }
        Debug.Log("LoadSpawnRooms() done, [" + rooms.Length.ToString() + "] spawn rooms found.");
    }
    private void _LoadRooms()
    {
        string _debugger_info = "";
        _room_lib = new RoomLibrary();
        GameObject[] rooms = Resources.LoadAll<GameObject>("Rooms");
        if (rooms.Length == 0)
            Debug.LogError("No rooms found!");
        foreach (GameObject g in rooms)
        {
            Room r = g.GetComponent<Room>();
            _room_lib.Add(r);
        }
        _debugger_info += "LoadRooms() done.\n" + _room_lib.ToString();
        Debug.Log(_debugger_info);
    }
    private void CreateSpawn(Vector2 pos)
    {
        Room r = Instantiate<Room>(_spawn_rooms[UnityEngine.Random.Range(0,_spawn_rooms.Count)]);
        r.transform.parent = this.transform;
        r.transform.position = new Vector3(pos.x, pos.y, r.transform.position.z);
        
        NetworkServer.Spawn(r.gameObject);
        current_rooms.Add(r);
    }
    private IEnumerator GenerateRooms()
    {
        while (!done)
        {
            int entrances = 2;

            // while we're accelerating, we don't want rooms with less entrances than 2
            if (current_rooms.Count < AccelerateUntil)
            {
                entrances = UnityEngine.Random.Range(2, 5);
            }

            // while we're decelerating, we don't want rooms with more than 2 entrances.
            // this is when we start closing off entrances.
            // TODO: There's cases where the only possible room to place needs to have more than 2 entrances
            if (current_rooms.Count >= DecelerateAt)
            {
                entrances = UnityEngine.Random.Range(1, 3);
            }

            Vector2 size = new Vector2(1, 1);
            Room r = Instantiate<Room>(_room_lib.GetRandom(entrances, size));

            r.transform.parent = this.transform;

            if (r.Add(current_rooms))
            {
                current_rooms.Add(r);
                UpdateAvailableEntrancesAll();
                NetworkServer.Spawn(r.gameObject);
            }
            else
            {
                Destroy(r.gameObject);
            }

            if (AvailableEntrances() == 0)
            {
                done = true;
                break;
            }

            yield return null;
        }
    }

    private void OnStartHost()
    {
        Debug.Log("Hosted");
    }
}